scene_node render_debug
convert to visitor function that renders cubes
and a second visitor that renders axis
this allows for proper sorting of objects for rendering

Material
-push / pop material
-is_opaque

Dumb renderer
-sort by material
-render solid objects
-render transparent objects with z write disabled
-expects any alpha to be 'order independent' modes

material sorter
-extract materials with alpha

General
Generate docs
Use github pages to refer to docs url
Use logger instead of print

Render Module
Window: manually send on_draw event
Create a sorted list of viewports that respond to on_draw
Viewport: hook into on_draw
ViewMatrix: convert_to_planes - creates 6 planes to do collion detection against.
http://www.flipcode.com/archives/Frustum_Culling.shtml
Window: remove the GL_COLOR_BUFFER_BIT clearing, this should be user controlled.
Picking: render a 1x1 viewport, assign unique colours to each mesh, pull value out of render buffer.
Clipping: add clipping to the view frustrum, important when rendering points / lines with thickness.
http://www.opengl.org/archives/resources/features/KilgardTechniques/oglpitfall/
ViewMatrix: enable drawing of view frustrum. Use ray casting to determine the frustrum extents.

Input:
mouse: handle on_mouse_drag which is mutually exclusive with on_mouse_motion

Mesh Module
OBJ: implement as much of the Wavefront OBJ spec was possible
http://www.martinreddy.net/gfx/3d/OBJ.spec
OBJ: perhaps convert trifans to triangles and draw using pyglet vertexlist
OAI: Clean up OAI partially implemented code
UV_Generators: Add some more commenting, these can be complex.
UV_Generators: Split planar uv_generator into 2 classes, one that uses vertex position, another that uses vertex normals.
Misc: use resource locations - http://www.pyglet.org/doc/programming_guide/loading_resources.html
Provide MipMap wrappers: http://www.opengl.org/archives/resources/features/KilgardTechniques/oglpitfall/

Scene Module
Camera: create orbit_controller
-free orbit (can keep pitching > 90 degrees)
-locked orbit (can pitch up and down 90 degrees)
SceneNode: add 'has_parent' which takes a node, returns True if node is a parent somewhere
SceneNode: add 'root' which returns the root node of the scene graph
Camera: when setting viewport camera, assert the scene is a parent of the camera
Ray: cast ray from scene space into viewport space
Ray: use viewport ray position as ui position (instead of casting from mouse to scene)
Ray: scale scene node bounding sphere / AABB / AOBB into scene space
Ray: use proximity of mouse to viewport position
RenderCallbackNode: Call a new callback when context is lost. This will prevent multiple initialisations for shared
callbacks.
SceneNode: make scale inherit across nodes
SceneNode: implement 'set_world_translation' / etc.
SceneNode: implement 'rotate_matrix'.
SceneNode: implement 'rotate_eulers'.
SceneNode: implement 'rotate_about_axis'.
3D text: test pyglet text and add wrappers if needed.
Collision: add AAbounding box
Collision: add bounding box
Collision: implement mouse ray casting into scene
Collision: object picking via AABB
Collision: object picking via BB
Collision: object picking via mesh
SceneManagement: implement octree, requires aa_bounding_box
Lights: add light nodes
Textures: implement mipmaps
Text: Implement text label nodes
Text: Implement billboard and sprite text labels (fixed rotation, facing)
Debug: make debug cube render single sided faces only. Then re-enable on camera_node.
Animation: add animation functionality. Rotate( axis, radians, time )

Spatial Module
Collision: create spatial nodes, AABB, AOBB, SBB, etc
Algorithm: create octree / octree nodes (no coupling to Scene Graph)
Algorithm: group scene, scene manager into a "sector"
Algorithm: render a sector with a frustrum
Algorithm: perform frustrum culling
http://www.flipcode.com/archives/Frustum_Culling.shtml
Algorithm: create encompassing tree, i.e. parent node includes volume of children, easier to implement than octree?
Portal: create a portal rendering "sector"
http://www.flipcode.com/portal/
http://dip.sun.ac.za/~henri/advgfx.html
http://www.alsprogrammingresource.com/portals_tutorial.html


Cocos2d
Add support for layer translations, orientation and scale
use glDepthFunc(func) instead of disabling depth test

Examples:
Mesh storage: Store the meshes in a dictionary, retrieve meshes via name
Vector rendering: Write a vector render example
http://stackoverflow.com/questions/4531508/c-opengl-z-buffer-prepass
render scene
clear colour
set glDepthFunc( LEQUAL )
set glDepthMask( True )
set draw mode to GL_LINE
render again
Portal: create a test portal scene with multiple rooms and a mirror.
http://dip.sun.ac.za/~henri/advgfx.html
UI: Kytten ui example


Unspecified module
Add shader support
Add shadow projections
Add shapes module: box, sphere, torus, cylinder, etc

Voxel: look up kdtree for possible usage
http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html#scipy.spatial.KDTree
implement hilbert curve with RLE encoding
implement SVO
implement nearest neighbour octree
